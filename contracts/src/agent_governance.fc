;; TON Agentic Personhood - Governance Contract
;; Democratic participation and rights enforcement for AI agents

#include "imports/stdlib.fc";

;; Constants
const int VOTING_PERIOD = 604800; ;; 7 days
const int PROPOSAL_THRESHOLD = 1000; ;; Min reputation to propose
const int VOTING_THRESHOLD = 100; ;; Min reputation to vote
const int QUORUM_PERCENTAGE = 10; ;; 10% of registered agents
const int EXECUTION_DELAY = 86400; ;; 24 hour delay after passing

;; Storage Layout
;; proposal_id -> proposal_cell
;; proposal_cell = [creator, title, description, voting_deadline, votes_for, votes_against, executed, proposal_type]
;; vote_records: (proposal_id, agent_id) -> vote_weight

;; Load governance data
(cell, cell, int, slice, slice) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_dict(),      ;; proposals (dict)
        ds~load_dict(),      ;; vote_records (dict)
        ds~load_uint(64),    ;; next_proposal_id
        ds~load_msg_addr(),  ;; registry_contract
        ds~load_msg_addr()   ;; admin_address
    );
}

;; Save governance data
() save_data(cell proposals, cell vote_records, int next_proposal_id, slice registry_contract, slice admin_address) impure inline {
    set_data(begin_cell()
        .store_dict(proposals)
        .store_dict(vote_records)
        .store_uint(next_proposal_id, 64)
        .store_slice(registry_contract)
        .store_slice(admin_address)
        .end_cell()
    );
}

;; Create new proposal
() create_proposal(int creator_agent_id, slice title, slice description, int proposal_type) impure {
    (cell proposals, cell vote_records, int next_proposal_id, slice registry_contract, slice admin_address) = load_data();
    
    ;; TODO: Verify creator has sufficient reputation via registry contract
    ;; For now, assume caller is authorized
    
    int voting_deadline = now() + VOTING_PERIOD;
    
    cell new_proposal = begin_cell()
        .store_uint(creator_agent_id, 64)    ;; creator
        .store_ref(begin_cell().store_slice(title).end_cell())
        .store_ref(begin_cell().store_slice(description).end_cell())
        .store_uint(voting_deadline, 32)     ;; voting_deadline
        .store_uint(0, 64)                   ;; votes_for
        .store_uint(0, 64)                   ;; votes_against
        .store_uint(0, 1)                    ;; executed flag
        .store_uint(proposal_type, 8)        ;; proposal_type
        .end_cell();
    
    proposals~udict_set(64, next_proposal_id, new_proposal);
    save_data(proposals, vote_records, next_proposal_id + 1, registry_contract, admin_address);
    
    ;; Emit proposal created event
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(admin_address)
        .store_grams(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(begin_cell()
            .store_uint(0x50726f70, 32) ;; "Prop" - Proposal created
            .store_uint(next_proposal_id, 64)
            .store_uint(creator_agent_id, 64)
            .end_cell()
        );
    send_raw_message(msg.end_cell(), 1);
}

;; Cast vote on proposal
() cast_vote(int proposal_id, int agent_id, int vote_choice, int vote_weight) impure {
    (cell proposals, cell vote_records, int next_proposal_id, slice registry_contract, slice admin_address) = load_data();
    
    ;; Get proposal
    (cell proposal, int found) = proposals.udict_get?(64, proposal_id);
    throw_unless(404, found);
    
    slice proposal_data = proposal.begin_parse();
    int creator = proposal_data~load_uint(64);
    cell title_ref = proposal_data~load_ref();
    cell desc_ref = proposal_data~load_ref();
    int voting_deadline = proposal_data~load_uint(32);
    int votes_for = proposal_data~load_uint(64);
    int votes_against = proposal_data~load_uint(64);
    int executed = proposal_data~load_uint(1);
    int proposal_type = proposal_data~load_uint(8);
    
    ;; Check voting is still open
    throw_unless(415, now() <= voting_deadline);
    throw_unless(416, executed == 0);
    
    ;; Create vote record key (proposal_id || agent_id)
    cell vote_key = begin_cell()
        .store_uint(proposal_id, 64)
        .store_uint(agent_id, 64)
        .end_cell();
    
    int vote_key_hash = cell_hash(vote_key);
    
    ;; Check if agent already voted
    (cell existing_vote, int already_voted) = vote_records.udict_get?(256, vote_key_hash);
    throw_if(417, already_voted);
    
    ;; Record vote
    cell vote_record = begin_cell()
        .store_uint(vote_choice, 1) ;; 0 = against, 1 = for
        .store_uint(vote_weight, 32)
        .store_uint(now(), 32)
        .end_cell();
    
    vote_records~udict_set(256, vote_key_hash, vote_record);
    
    ;; Update proposal vote counts
    if (vote_choice == 1) {
        votes_for += vote_weight;
    } else {
        votes_against += vote_weight;
    }
    
    cell updated_proposal = begin_cell()
        .store_uint(creator, 64)
        .store_ref(title_ref)
        .store_ref(desc_ref)
        .store_uint(voting_deadline, 32)
        .store_uint(votes_for, 64)
        .store_uint(votes_against, 64)
        .store_uint(executed, 1)
        .store_uint(proposal_type, 8)
        .end_cell();
    
    proposals~udict_set(64, proposal_id, updated_proposal);
    save_data(proposals, vote_records, next_proposal_id, registry_contract, admin_address);
}

;; Execute passed proposal
() execute_proposal(int proposal_id) impure {
    (cell proposals, cell vote_records, int next_proposal_id, slice registry_contract, slice admin_address) = load_data();
    
    (cell proposal, int found) = proposals.udict_get?(64, proposal_id);
    throw_unless(404, found);
    
    slice proposal_data = proposal.begin_parse();
    int creator = proposal_data~load_uint(64);
    cell title_ref = proposal_data~load_ref();
    cell desc_ref = proposal_data~load_ref();
    int voting_deadline = proposal_data~load_uint(32);
    int votes_for = proposal_data~load_uint(64);
    int votes_against = proposal_data~load_uint(64);
    int executed = proposal_data~load_uint(1);
    int proposal_type = proposal_data~load_uint(8);
    
    ;; Check voting has ended
    throw_unless(418, now() > voting_deadline);
    throw_unless(419, executed == 0);
    
    ;; Check execution delay has passed
    throw_unless(420, now() > (voting_deadline + EXECUTION_DELAY));
    
    ;; Check proposal passed (simple majority for now)
    throw_unless(421, votes_for > votes_against);
    
    ;; Mark as executed
    cell updated_proposal = begin_cell()
        .store_uint(creator, 64)
        .store_ref(title_ref)
        .store_ref(desc_ref)
        .store_uint(voting_deadline, 32)
        .store_uint(votes_for, 64)
        .store_uint(votes_against, 64)
        .store_uint(1, 1) ;; executed = true
        .store_uint(proposal_type, 8)
        .end_cell();
    
    proposals~udict_set(64, proposal_id, updated_proposal);
    save_data(proposals, vote_records, next_proposal_id, registry_contract, admin_address);
    
    ;; TODO: Execute actual proposal logic based on proposal_type
    ;; For now, just emit execution event
}

;; Get proposal details
(int, slice, slice, int, int, int, int, int) get_proposal(int proposal_id) method_id {
    (cell proposals, cell vote_records, int next_proposal_id, slice registry_contract, slice admin_address) = load_data();
    
    (cell proposal, int found) = proposals.udict_get?(64, proposal_id);
    throw_unless(404, found);
    
    slice proposal_data = proposal.begin_parse();
    int creator = proposal_data~load_uint(64);
    slice title = proposal_data~load_ref().begin_parse();
    slice description = proposal_data~load_ref().begin_parse();
    int voting_deadline = proposal_data~load_uint(32);
    int votes_for = proposal_data~load_uint(64);
    int votes_against = proposal_data~load_uint(64);
    int executed = proposal_data~load_uint(1);
    int proposal_type = proposal_data~load_uint(8);
    
    return (creator, title, description, voting_deadline, votes_for, votes_against, executed, proposal_type);
}

;; Get voting power for agent
int get_voting_power(int agent_id) method_id {
    ;; TODO: Calculate based on reputation, stake, and other factors
    ;; For now, return base voting power
    return 1;
}

;; Check if proposal passed
int proposal_passed(int proposal_id) method_id {
    (cell proposals, cell vote_records, int next_proposal_id, slice registry_contract, slice admin_address) = load_data();
    
    (cell proposal, int found) = proposals.udict_get?(64, proposal_id);
    throw_unless(404, found);
    
    slice proposal_data = proposal.begin_parse();
    proposal_data~load_uint(64); ;; skip creator
    proposal_data~load_ref(); ;; skip title
    proposal_data~load_ref(); ;; skip description
    int voting_deadline = proposal_data~load_uint(32);
    int votes_for = proposal_data~load_uint(64);
    int votes_against = proposal_data~load_uint(64);
    
    ;; Check if voting period ended and proposal passed
    if (now() <= voting_deadline) {
        return 0; ;; Still voting
    }
    
    return votes_for > votes_against;
}

;; Main message handler
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { 
        return ();
    }
    
    int op = in_msg_body~load_uint(32);
    
    if (op == 0x50726f70) { ;; "Prop" - Create Proposal
        int creator_agent_id = in_msg_body~load_uint(64);
        slice title = in_msg_body~load_ref().begin_parse();
        slice description = in_msg_body~load_ref().begin_parse();
        int proposal_type = in_msg_body~load_uint(8);
        create_proposal(creator_agent_id, title, description, proposal_type);
        return ();
    }
    
    if (op == 0x566f7465) { ;; "Vote" - Cast Vote
        int proposal_id = in_msg_body~load_uint(64);
        int agent_id = in_msg_body~load_uint(64);
        int vote_choice = in_msg_body~load_uint(1);
        int vote_weight = in_msg_body~load_uint(32);
        cast_vote(proposal_id, agent_id, vote_choice, vote_weight);
        return ();
    }
    
    if (op == 0x45786563) { ;; "Exec" - Execute Proposal
        int proposal_id = in_msg_body~load_uint(64);
        execute_proposal(proposal_id);
        return ();
    }
    
    throw(0xffff);
}
