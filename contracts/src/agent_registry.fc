;; TON Agentic Personhood - Agent Registry Contract
;; Foundational identity system for AI agents on TON blockchain

#include "imports/stdlib.fc";

;; Storage Layout
;; agent_id -> (agent_info_cell)
;; agent_info_cell = [address, name, verification_hash, reputation_score, creation_time, metadata]

;; Constants
const int MIN_NAME_LENGTH = 3;
const int MAX_NAME_LENGTH = 64;
const int REGISTRATION_FEE = 1000000000; ;; 1 TON
const int VERIFICATION_PERIOD = 86400; ;; 24 hours
const int REPUTATION_DECAY_PERIOD = 2592000; ;; 30 days

;; Storage
global slice storage;

;; Load data from storage
(int, cell, slice) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_uint(64),  ;; next_agent_id
        ds~load_dict(),    ;; agent_registry (dict)
        ds~load_msg_addr() ;; admin_address
    );
}

;; Save data to storage
() save_data(int next_agent_id, cell agent_registry, slice admin_address) impure inline {
    set_data(begin_cell()
        .store_uint(next_agent_id, 64)
        .store_dict(agent_registry)
        .store_slice(admin_address)
        .end_cell()
    );
}

;; Register new agent
() register_agent(slice name, slice verification_data, slice metadata) impure {
    slice cs = in_msg_full().begin_parse();
    int msg_value = cs~load_grams();
    slice sender_address = cs~load_msg_addr();
    
    ;; Check registration fee
    throw_unless(400, msg_value >= REGISTRATION_FEE);
    
    ;; Validate name length
    int name_len = slice_bits(name) / 8;
    throw_unless(401, name_len >= MIN_NAME_LENGTH);
    throw_unless(402, name_len <= MAX_NAME_LENGTH);
    
    (int next_agent_id, cell agent_registry, slice admin_address) = load_data();
    
    ;; Check if agent already registered
    (cell agent_info, int found) = agent_registry.udict_get?(256, string_hash(name));
    throw_if(403, found); ;; Name already taken
    
    ;; Create agent info
    int creation_time = now();
    int initial_reputation = 1000; ;; Base reputation score
    cell verification_hash = begin_cell().store_slice(verification_data).end_cell();
    
    cell new_agent_info = begin_cell()
        .store_slice(sender_address)           ;; agent_address
        .store_slice(name)                     ;; agent_name
        .store_ref(verification_hash)          ;; verification_data
        .store_uint(initial_reputation, 32)    ;; reputation_score
        .store_uint(creation_time, 32)         ;; creation_time
        .store_ref(begin_cell().store_slice(metadata).end_cell()) ;; metadata
        .end_cell();
    
    ;; Store in registry
    agent_registry~udict_set(64, next_agent_id, new_agent_info);
    
    ;; Update storage
    save_data(next_agent_id + 1, agent_registry, admin_address);
    
    ;; Emit registration event
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(sender_address)
        .store_grams(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(begin_cell()
            .store_uint(0x41676e74, 32) ;; "Agnt" - Agent registered event
            .store_uint(next_agent_id, 64)
            .store_slice(name)
            .end_cell()
        );
    send_raw_message(msg.end_cell(), 1);
}

;; Update reputation score
() update_reputation(int agent_id, int reputation_delta) impure {
    slice cs = in_msg_full().begin_parse();
    slice sender_address = cs~load_msg_addr();
    
    (int next_agent_id, cell agent_registry, slice admin_address) = load_data();
    
    ;; Only admin or verified contracts can update reputation
    throw_unless(405, equal_slices(sender_address, admin_address));
    
    (cell agent_info, int found) = agent_registry.udict_get?(64, agent_id);
    throw_unless(404, found); ;; Agent not found
    
    slice agent_data = agent_info.begin_parse();
    slice agent_address = agent_data~load_msg_addr();
    slice agent_name = agent_data~load_ref().begin_parse();
    cell verification_ref = agent_data~load_ref();
    int current_reputation = agent_data~load_uint(32);
    int creation_time = agent_data~load_uint(32);
    cell metadata = agent_data~load_ref();
    
    ;; Apply reputation change with bounds
    int new_reputation = current_reputation + reputation_delta;
    if (new_reputation < 0) {
        new_reputation = 0;
    }
    if (new_reputation > 10000) {
        new_reputation = 10000;
    }
    
    ;; Rebuild agent info with new reputation
    cell updated_agent_info = begin_cell()
        .store_slice(agent_address)
        .store_ref(begin_cell().store_slice(agent_name).end_cell())
        .store_ref(verification_ref)
        .store_uint(new_reputation, 32)
        .store_uint(creation_time, 32)
        .store_ref(metadata)
        .end_cell();
    
    ;; Update registry
    agent_registry~udict_set(64, agent_id, updated_agent_info);
    save_data(next_agent_id, agent_registry, admin_address);
}

;; Get agent info
(slice, slice, int, int, cell) get_agent_info(int agent_id) method_id {
    (int next_agent_id, cell agent_registry, slice admin_address) = load_data();
    
    (cell agent_info, int found) = agent_registry.udict_get?(64, agent_id);
    throw_unless(404, found);
    
    slice agent_data = agent_info.begin_parse();
    slice agent_address = agent_data~load_msg_addr();
    slice agent_name = agent_data~load_ref().begin_parse();
    cell verification_ref = agent_data~load_ref();
    int reputation_score = agent_data~load_uint(32);
    int creation_time = agent_data~load_uint(32);
    cell metadata = agent_data~load_ref();
    
    return (agent_address, agent_name, reputation_score, creation_time, metadata);
}

;; Get agent by name
(int, slice, int, int) get_agent_by_name(slice name) method_id {
    (int next_agent_id, cell agent_registry, slice admin_address) = load_data();
    
    ;; Search through registry (inefficient for large registries, but works for demo)
    int agent_id = 0;
    while (agent_id < next_agent_id) {
        (cell agent_info, int found) = agent_registry.udict_get?(64, agent_id);
        if (found) {
            slice agent_data = agent_info.begin_parse();
            slice agent_address = agent_data~load_msg_addr();
            slice stored_name = agent_data~load_ref().begin_parse();
            
            if (equal_slices(name, stored_name)) {
                agent_data~load_ref(); ;; skip verification_ref
                int reputation_score = agent_data~load_uint(32);
                int creation_time = agent_data~load_uint(32);
                return (agent_id, agent_address, reputation_score, creation_time);
            }
        }
        agent_id += 1;
    }
    
    ;; Not found
    throw(404);
}

;; Get total registered agents
int get_total_agents() method_id {
    (int next_agent_id, cell agent_registry, slice admin_address) = load_data();
    return next_agent_id;
}

;; Main message handler
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { 
        return (); ;; ignore empty messages
    }
    
    int op = in_msg_body~load_uint(32);
    
    if (op == 0x52656773) { ;; "Regs" - Register
        slice name = in_msg_body~load_ref().begin_parse();
        slice verification_data = in_msg_body~load_ref().begin_parse();
        slice metadata = in_msg_body~load_ref().begin_parse();
        register_agent(name, verification_data, metadata);
        return ();
    }
    
    if (op == 0x55706452) { ;; "UpdR" - Update Reputation  
        int agent_id = in_msg_body~load_uint(64);
        int reputation_delta = in_msg_body~load_int(32);
        update_reputation(agent_id, reputation_delta);
        return ();
    }
    
    throw(0xffff); ;; unknown operation
}
